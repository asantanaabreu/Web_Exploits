# Define needed packages
import getpass
import subprocess
import os
import re
import datetime

# Variables used throughout the program
current_user = getpass.getuser()  # Obtain the current user
directory = f"/home/{current_user}/Web"

if not os.path.exists(directory): # If a directory Web doesn't exists, create it.
    os.makedirs(directory)

Report = f"{directory}/Results.txt" # The final report
now = datetime.datetime.now()  # Obtain the date and time in which the script is being executed.

# Write into the report the date and time of the results.
with open(Report,"w") as r:
    r.write("Results "+str(now)+'\n\n')
    r.close()


def dirb():  # Function to treat the dirb command.
    # Run the dirb command and redirect its output to a file
    file = f"{directory}/dirb_temp.txt"

    with open(file, 'w') as f:
        subprocess.run(['dirb',url_option], stdout=f)

    # Read the file, filter out lines containing the word "Testing", and write the filtered lines back to the file without blank lines
    with open(file, 'r') as f:
        lines = f.readlines()
        f.close()
    filtered_lines = [line.strip() for line in lines if 'Testing' not in line]

    with open(file, 'w') as f:
        f.write('\n'.join(filtered_lines))
        grep = fr"grep '\S'  {file} >> {Report}"
        subprocess.run(grep, shell=True, capture_output=True, text=True)
        subprocess.run(['rm', file])


url_option = input ("\nTell us the victim's URL\n")

location = f"{directory}/output.txt"  # Temporary document to store the domains found in phpMyadmin
with open(os.devnull, "w") as devnull:  # The output is not going to be presented in the python console
    subprocess.run(["curl", url_option, "-o", location], stdout=devnull, stderr=devnull)

    with open(location) as lc:
        text = lc.read()
        directories = re.findall(r'<a href="(/[^"]+)">', text)  # Taking href as reference, it will find the domains
        with open(Report, "a") as r:
            r.write(f"The directories found are: {directories}\n\n")
            r.close()

    if '/phpMyAdmin/' in directories:
        new_url = url_option+'/phpMyAdmin/'
    # Download the webpage with wget and save it to a file named index.html in the specified directory
        with open(os.devnull, "w") as devnull:
            subprocess.run(["wget", new_url, "-O", f"{directory}/index2.html"],stdout=devnull, stderr=devnull)

    # Extract the URLs from the downloaded webpage using grep, cut, and sort, and save the list
        # to a file named list.txt in the specified directory
        # First part of cmd1. It is divided into two due to the different characters that Python considers as special
        # characters, the first part instructs Python to use it in raw mode, ignoring special characters.
        # The second part is used to recognize the backslash to indicate that the double quotes are part of the command.
        cmd1_part1 = fr"grep 'href=' {directory}/index2.html | cut -d '/' -f 3 | grep '\.' "
        # Second part of the command
        cmd1_part2 = f" | cut -d '\"' -f 1 | sort -u > {directory}/list.txt"
        # Combine the two parts
        cmd1 = cmd1_part1 + cmd1_part2
        # Run
        subprocess.run(cmd1, shell=True)
        # Look up the IP addresses for the URLs in the list.txt file using host, grep, cut, and sort
        cmd2 = f"for url in $(cat {directory}/list.txt); do host $url; done | grep 'has address' | cut -d ' ' -f 4 | sort -u"
        result = subprocess.run(cmd2, shell=True, capture_output=True, text=True)
        subprocess.run(['rm', f"{directory}/list.txt"])  # Delete the temporary file.
        subprocess.run(['rm', location])  # Delete temporary file

        with open(Report, "a") as r:
            r.write(f"The IP addresses in phpMyAdmin are:\n{result.stdout}\n")
            r.close()

with open(Report,"a") as r:
    r.write("\n\n--BASIC INFORMATION OBTAINED ABOUT THE WEBSITE--\n\n")
   # Whatweb is a command that provides information about the website running. 
    whatweb = subprocess.run(['whatweb', url_option], capture_output=True, text=True)
    ansi = re.compile(r'\x1B\[[0-?]*[ -/]*[@-~]')  # the output of the command has ANSI escape sequences
                                                    # so is necessary to remove those characters and use others that
                                                    # match the sequence and replace it with an empty space.
    clean = ansi.sub('', whatweb.stdout)  # The sequence is replaced.
    r.write(clean)
    r.close()

with open(Report,"a") as r:
    r.write("\n\n--DIRB RESULTS--\n\n")
    r.close()
    dirb()  # call the previously created ufnction

with open(Report,"a") as r:  
    r.write("\n\n--NIKTO RESULTS--\n\n")
    # Run Nikto against the page. 
    nikto = subprocess.run(["nikto", "-h", url_option], capture_output=True, text=True)
    r.write(nikto.stdout)
    r.close()

